import { Injectable, inject } from "@angular/core";
import { Observable, ReplaySubject, fromEvent, of, race, throwError } from "rxjs";
import { first, map, mergeMap, takeWhile, tap } from "rxjs/operators";
import { IDB_DB_NAME, IDB_DB_VERSION, IDB_NO_WRAP, IDB_STORE_NAME } from "../tokens";
import { IDBBrokenError } from "./exceptions";
import { LocalDatabase } from "./local-database";
import * as i0 from "@angular/core";
export class IndexedDBDatabase {
    constructor() {
        /**
         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection
         * even after the connection success event happened
         */
        this.database = new ReplaySubject(1);
        /**
         * Index used when wrapping value. *For backward compatibility only.*
         */
        this.wrapIndex = "value";
        this.dbName = inject(IDB_DB_NAME);
        this.storeName = inject(IDB_STORE_NAME);
        this.dbVersion = inject(IDB_DB_VERSION);
        this.noWrap = inject(IDB_NO_WRAP);
        /* Connect to `indexedDB`, with prefix if provided by the user */
        this.connect();
    }
    /**
     * Information about `indexedDB` connection. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version
     */
    get backingStore() {
        return {
            database: this.dbName,
            store: this.storeName,
            version: this.dbVersion,
        };
    }
    /**
     * Number of items in our `indexedDB` database and object store
     */
    get size() {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request to know the number of items */
            const request = store.count();
            /* Return the result */
            return events.pipe(map(() => request.result));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Gets an item value in our `indexedDB` store
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`
     */
    get(key) {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request the value with the key provided by the user */
            const request = store.get(key);
            /* Listen events and return the result */
            return events.pipe(map(() => {
                if ((request.result !== undefined) && (request.result !== null)) {
                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */
                    if (!this.noWrap && (typeof request.result === "object") && (this.wrapIndex in request.result) &&
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- Required by indexedDb behavior
                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- Required by indexedDb behavior
                        return request.result[this.wrapIndex];
                    }
                    else {
                        /* Cast to the wanted type */
                        return request.result;
                    }
                }
                /* Return `undefined` if the value is empty */
                return undefined;
            }));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Sets an item in our `indexedDB` store
     * @param key The item's key
     * @param data The item's value
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    set(key, data) {
        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */
        if (data === undefined) {
            return this.delete(key);
        }
        /* Open a transaction in write mode */
        return this.transaction("readwrite").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Prior to v8, data was wrapped in a `{ value: ... }` object */
            const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };
            /* Add if the item is not existing yet, or update otherwise */
            store.put(dataToStore, key);
            /* Listen to events and return `undefined` as no value is expected */
            return events.pipe(map(() => undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes an item in our `indexedDB` store
     * @param key The item's key
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    delete(key) {
        /* Open a transaction in write mode */
        return this.transaction("readwrite").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete the item in store */
            store.delete(key);
            /* Listen to events and return `undefined` as no data is expected here */
            return events.pipe(map(() => undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes all items from our `indexedDB` objet store
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    clear() {
        /* Open a transaction in write mode */
        return this.transaction("readwrite").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete all items in object store */
            store.clear();
            /* Listen to events and return `undefined` as no data is expected here */
            return events.pipe(map(() => undefined));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Get all the keys in our `indexedDB` store
     * @returns An RxJS `Observable` iterating on each key
     */
    keys() {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(
        /* `first()` is used as the final operator in other methods to complete the `Observable`
         * (as it all starts from a `ReplaySubject` which never ends),
         * but as this method is iterating over multiple values, `first()` **must** be used here */
        first(), mergeMap((transactionData) => {
            const { store } = transactionData;
            /* Open a cursor on the store
             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */
            const request = store.openKeyCursor();
            /* Listen to success event */
            const success$ = fromEvent(request, "success").pipe(
            /* Stop the `Observable` when the cursor is `null` */
            // eslint-disable-next-line rxjs/no-ignored-takewhile-value -- Required by indexedDb behavior, getting the result from the event does not always work
            takeWhile(() => (request.result !== null)), 
            /* This lib only allows string keys, but user could have added other types of keys from outside
             * It's OK to cast as the cursor as been tested in the previous operator */
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-base-to-string -- Required by indexedDb behavior, and strings are enforced by the lib
            map(() => request.result.key.toString()), 
            /* Iterate on the cursor */
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Required by indexedDb behavior
            tap(() => { request.result.continue(); }));
            /* Listen to error event and if so, throw an error */
            const error$ = this.listenError(request);
            /* Choose the first event to occur */
            return race([success$, error$]);
        }));
    }
    /**
     * Check if a key exists in our `indexedDB` store
     * @returns An RxJS `Observable` telling if the key exists or not
     */
    has(key) {
        /* Open a transaction in read-only mode */
        return this.transaction("readonly").pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Check if the key exists in the store
             * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69
             */
            const request = store.getKey(key);
            /* Listen to events and return `true` or `false` */
            return events.pipe(map(() => (request.result !== undefined) ? true : false));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Connects to `indexedDB` and creates the object store on first time
     */
    connect() {
        let request;
        /* Connect to `indexedDB`
         * Will fail in Safari cross-origin iframes
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */
        try {
            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */
            request = indexedDB.open(this.dbName, this.dbVersion);
        }
        catch {
            this.database.error(new IDBBrokenError());
            return;
        }
        /* Create store on first connection */
        this.createStore(request);
        /* Listen to success and error events */
        const success$ = fromEvent(request, "success");
        const error$ = this.listenError(request);
        /* Choose the first to occur */
        race([success$, error$])
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Register the database connection in the `ReplaySubject` for further access */
                this.database.next(request.result);
            },
            error: () => {
                /* Keeping this error management for safety, but it should not happen anymore.
                 * It was for Firefox private mode issue in Firefox versions < 115
                 * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */
                this.database.error(new IDBBrokenError());
            },
        });
    }
    /**
     * Create store on first use of `indexedDB`
     * @param request `indexedDB` database opening request
     */
    createStore(request) {
        /* Listen to the event fired on first connection */
        fromEvent(request, "upgradeneeded")
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Check if the store already exists, to avoid error */
                if (!request.result.objectStoreNames.contains(this.storeName)) {
                    /* Create the object store */
                    request.result.createObjectStore(this.storeName);
                }
            }
        });
    }
    /**
     * Open an `indexedDB` transaction and get our store
     * @param mode `readonly` or `readwrite`
     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`
     */
    transaction(mode) {
        /* From the `indexedDB` connection, open a transaction and get the store */
        return this.database
            .pipe(mergeMap((database) => {
            let transaction;
            try {
                transaction = database.transaction([this.storeName], mode);
            }
            catch (error) {
                /* The store could have been deleted from outside */
                return throwError(() => error);
            }
            /* Get the store from the transaction */
            const store = transaction.objectStore(this.storeName);
            /* Listen transaction `complete` and `error` events */
            const events = this.listenTransactionEvents(transaction);
            return of({ store, events });
        }));
    }
    /**
     * Listen errors on a transaction or request, and throw if trigerred
     * @param transactionOrRequest `indexedDb` transaction or request to listen
     * @returns An `Observable` listening to errors
     */
    listenError(transactionOrRequest) {
        return fromEvent(transactionOrRequest, "error").pipe(
        /* Throw on error to be able to catch errors in RxJS way.
         * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`
         * if we are on the request and the error is only triggered later by the transaction */
        mergeMap((event) => throwError(() => event.target?.error)));
    }
    /**
     * Listen transaction `complete` and `error` events
     * @param transaction Transaction to listen
     * @returns An `Observable` listening to transaction `complete` and `error` events
     */
    listenTransactionEvents(transaction) {
        /* Listen to the `complete` event */
        const complete$ = fromEvent(transaction, "complete");
        /* Listen to the `error` event */
        const error$ = this.listenError(transaction);
        /* Choose the first event to occur */
        return race([complete$, error$]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: IndexedDBDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: IndexedDBDatabase, providedIn: "root" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: IndexedDBDatabase, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root"
                }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGliL3NyYy9saWIvZGF0YWJhc2VzL2luZGV4ZWRkYi1kYXRhYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEYsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0RSxPQUFPLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3JGLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDOUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDOztBQUtqRCxNQUFNLE9BQU8saUJBQWlCO0lBaUM1QjtRQWhCQTs7O1dBR0c7UUFDYyxhQUFRLEdBQUcsSUFBSSxhQUFhLENBQWMsQ0FBQyxDQUFDLENBQUM7UUFPOUQ7O1dBRUc7UUFDYyxjQUFTLEdBQUcsT0FBTyxDQUFDO1FBSW5DLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRWxDLGlFQUFpRTtRQUNqRSxJQUFJLENBQUMsT0FBTyxF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QUNLLHVCQUF1QixDQUFDLFdBQTJCO1FBRXpELG9DQUFvQztRQUNwQyxNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRXJELGlDQUFpQztRQUNqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTdDLHFDQUFxQztRQUNyQyxPQUFPLElBQUksQ0FBQyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBRW5DLENBQUM7OEdBcmJVLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBRmhCLE1BQU07OzJGQUVQLGlCQUFpQjtrQkFIN0IsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBpbmplY3QgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCwgZnJvbUV2ZW50LCBvZiwgcmFjZSwgdGhyb3dFcnJvciB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBmaXJzdCwgbWFwLCBtZXJnZU1hcCwgdGFrZVdoaWxlLCB0YXAgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IElEQl9EQl9OQU1FLCBJREJfREJfVkVSU0lPTiwgSURCX05PX1dSQVAsIElEQl9TVE9SRV9OQU1FIH0gZnJvbSBcIi4uL3Rva2Vuc1wiO1xuaW1wb3J0IHsgSURCQnJva2VuRXJyb3IgfSBmcm9tIFwiLi9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBMb2NhbERhdGFiYXNlIH0gZnJvbSBcIi4vbG9jYWwtZGF0YWJhc2VcIjtcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiBcInJvb3RcIlxufSlcbmV4cG9ydCBjbGFzcyBJbmRleGVkREJEYXRhYmFzZSBpbXBsZW1lbnRzIExvY2FsRGF0YWJhc2Uge1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGRiTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBvYmplY3Qgc3RvcmUgbmFtZVxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBzdG9yZU5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgZGF0YWJhc2UgdmVyc2lvbi4gTXVzdCBiZSBhbiB1bnNpZ25lZCAqKmludGVnZXIqKlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkYlZlcnNpb246IG51bWJlcjtcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgZGF0YWJhc2UgY29ubmVjdGlvbiwgd3JhcHBlZCBpbiBhIFJ4SlMgYFJlcGxheVN1YmplY3RgIHRvIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBjb25uZWN0aW9uXG4gICAqIGV2ZW4gYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gc3VjY2VzcyBldmVudCBoYXBwZW5lZFxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkYXRhYmFzZSA9IG5ldyBSZXBsYXlTdWJqZWN0PElEQkRhdGFiYXNlPigxKTtcblxuICAvKipcbiAgICogRmxhZyB0byBub3Qgd3JhcCBgaW5kZXhlZERCYCB2YWx1ZXMgZm9yIGludGVyb3BlcmFiaWxpdHkgb3IgdG8gd3JhcCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgbm9XcmFwOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbmRleCB1c2VkIHdoZW4gd3JhcHBpbmcgdmFsdWUuICpGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbmx5LipcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgd3JhcEluZGV4ID0gXCJ2YWx1ZVwiO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgdGhpcy5kYk5hbWUgPSBpbmplY3QoSURCX0RCX05BTUUpO1xuICAgIHRoaXMuc3RvcmVOYW1lID0gaW5qZWN0KElEQl9TVE9SRV9OQU1FKTtcbiAgICB0aGlzLmRiVmVyc2lvbiA9IGluamVjdChJREJfREJfVkVSU0lPTik7XG4gICAgdGhpcy5ub1dyYXAgPSBpbmplY3QoSURCX05PX1dSQVApO1xuXG4gICAgLyogQ29ubmVjdCB0byBgaW5kZXhlZERCYCwgd2l0aCBwcmVmaXggaWYgcHJvdmlkZWQgYnkgdGhlIHVzZXIgKi9cbiAgICB0aGlzLmNvbm5lY3QoKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IGBpbmRleGVkREJgIGNvbm5lY3Rpb24uICpPbmx5IHVzZWZ1bCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4qXG4gICAqIEByZXR1cm5zIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWUsIHN0b3JlIG5hbWUgYW5kIGRhdGFiYXNlIHZlcnNpb25cbiAgICovXG4gIGdldCBiYWNraW5nU3RvcmUoKTogeyBkYXRhYmFzZTogc3RyaW5nLCBzdG9yZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXI7IH0ge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFiYXNlOiB0aGlzLmRiTmFtZSxcbiAgICAgIHN0b3JlOiB0aGlzLnN0b3JlTmFtZSxcbiAgICAgIHZlcnNpb246IHRoaXMuZGJWZXJzaW9uLFxuICAgIH07XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgaXRlbXMgaW4gb3VyIGBpbmRleGVkREJgIGRhdGFiYXNlIGFuZCBvYmplY3Qgc3RvcmVcbiAgICovXG4gIGdldCBzaXplKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbihcInJlYWRvbmx5XCIpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogUmVxdWVzdCB0byBrbm93IHRoZSBudW1iZXIgb2YgaXRlbXMgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNvdW50KCk7XG5cbiAgICAgICAgLyogUmV0dXJuIHRoZSByZXN1bHQgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcCgoKSA9PiByZXF1ZXN0LnJlc3VsdCkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGl0ZW0gdmFsdWUgaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGFuIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqL1xuICBnZXQoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd24+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiByZWFkLW9ubHkgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKFwicmVhZG9ubHlcIikucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBSZXF1ZXN0IHRoZSB2YWx1ZSB3aXRoIHRoZSBrZXkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChrZXkpO1xuXG4gICAgICAgIC8qIExpc3RlbiBldmVudHMgYW5kIHJldHVybiB0aGUgcmVzdWx0ICovXG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXAoKCk6IHVua25vd24gPT4ge1xuXG4gICAgICAgICAgaWYgKChyZXF1ZXN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSAmJiAocmVxdWVzdC5yZXN1bHQgIT09IG51bGwpKSB7XG5cbiAgICAgICAgICAgIC8qIFByaW9yIHRvIHY4LCB0aGUgdmFsdWUgd2FzIHdyYXBwZWQgaW4gYW4gYHsgdmFsdWU6IC4uLn1gIG9iamVjdCAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vV3JhcCAmJiAodHlwZW9mIHJlcXVlc3QucmVzdWx0ID09PSBcIm9iamVjdFwiKSAmJiAodGhpcy53cmFwSW5kZXggaW4gcmVxdWVzdC5yZXN1bHQpICYmXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgLS0gUmVxdWlyZWQgYnkgaW5kZXhlZERiIGJlaGF2aW9yXG4gICAgICAgICAgICAgIChyZXF1ZXN0LnJlc3VsdFt0aGlzLndyYXBJbmRleF0gIT09IHVuZGVmaW5lZCkgJiYgKHJlcXVlc3QucmVzdWx0W3RoaXMud3JhcEluZGV4XSAhPT0gbnVsbCkpIHtcblxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzIC0tIFJlcXVpcmVkIGJ5IGluZGV4ZWREYiBiZWhhdmlvclxuICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5yZXN1bHRbdGhpcy53cmFwSW5kZXhdO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIC8qIENhc3QgdG8gdGhlIHdhbnRlZCB0eXBlICovXG4gICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LnJlc3VsdDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSAqL1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgfSkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGl0ZW0gaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIGRhdGEgVGhlIGl0ZW0ncyB2YWx1ZVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgc2V0KGtleTogc3RyaW5nLCBkYXRhOiB1bmtub3duKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIC8qIFN0b3JpbmcgYHVuZGVmaW5lZGAgaW4gYGluZGV4ZWREYmAgY2FuIGNhdXNlIGlzc3VlcyBpbiBzb21lIGJyb3dzZXJzIHNvIHJlbW92aW5nIGl0ZW0gaW5zdGVhZCAqL1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiB3cml0ZSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oXCJyZWFkd3JpdGVcIikucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBQcmlvciB0byB2OCwgZGF0YSB3YXMgd3JhcHBlZCBpbiBhIGB7IHZhbHVlOiAuLi4gfWAgb2JqZWN0ICovXG4gICAgICAgIGNvbnN0IGRhdGFUb1N0b3JlID0gdGhpcy5ub1dyYXAgPyBkYXRhIDogeyBbdGhpcy53cmFwSW5kZXhdOiBkYXRhIH07XG5cbiAgICAgICAgLyogQWRkIGlmIHRoZSBpdGVtIGlzIG5vdCBleGlzdGluZyB5ZXQsIG9yIHVwZGF0ZSBvdGhlcndpc2UgKi9cbiAgICAgICAgc3RvcmUucHV0KGRhdGFUb1N0b3JlLCBrZXkpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBldmVudHMgYW5kIHJldHVybiBgdW5kZWZpbmVkYCBhcyBubyB2YWx1ZSBpcyBleHBlY3RlZCAqL1xuICAgICAgICByZXR1cm4gZXZlbnRzLnBpcGUobWFwKCgpID0+IHVuZGVmaW5lZCkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGl0ZW0gaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKFwicmVhZHdyaXRlXCIpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogRGVsZXRlIHRoZSBpdGVtIGluIHN0b3JlICovXG4gICAgICAgIHN0b3JlLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBldmVudHMgYW5kIHJldHVybiBgdW5kZWZpbmVkYCBhcyBubyBkYXRhIGlzIGV4cGVjdGVkIGhlcmUgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcCgoKSA9PiB1bmRlZmluZWQpKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaXRlbXMgZnJvbSBvdXIgYGluZGV4ZWREQmAgb2JqZXQgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKFwicmVhZHdyaXRlXCIpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogRGVsZXRlIGFsbCBpdGVtcyBpbiBvYmplY3Qgc3RvcmUgKi9cbiAgICAgICAgc3RvcmUuY2xlYXIoKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gZXZlbnRzIGFuZCByZXR1cm4gYHVuZGVmaW5lZGAgYXMgbm8gZGF0YSBpcyBleHBlY3RlZCBoZXJlICovXG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXAoKCkgPT4gdW5kZWZpbmVkKSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUga2V5cyBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgaXRlcmF0aW5nIG9uIGVhY2gga2V5XG4gICAqL1xuICBrZXlzKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbihcInJlYWRvbmx5XCIpLnBpcGUoXG4gICAgICAvKiBgZmlyc3QoKWAgaXMgdXNlZCBhcyB0aGUgZmluYWwgb3BlcmF0b3IgaW4gb3RoZXIgbWV0aG9kcyB0byBjb21wbGV0ZSB0aGUgYE9ic2VydmFibGVgXG4gICAgICAgKiAoYXMgaXQgYWxsIHN0YXJ0cyBmcm9tIGEgYFJlcGxheVN1YmplY3RgIHdoaWNoIG5ldmVyIGVuZHMpLFxuICAgICAgICogYnV0IGFzIHRoaXMgbWV0aG9kIGlzIGl0ZXJhdGluZyBvdmVyIG11bHRpcGxlIHZhbHVlcywgYGZpcnN0KClgICoqbXVzdCoqIGJlIHVzZWQgaGVyZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogT3BlbiBhIGN1cnNvciBvbiB0aGUgc3RvcmVcbiAgICAgICAgICogQXZvaWQgaXNzdWVzIGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNjkgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLm9wZW5LZXlDdXJzb3IoKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gc3VjY2VzcyBldmVudCAqL1xuICAgICAgICBjb25zdCBzdWNjZXNzJCA9IGZyb21FdmVudChyZXF1ZXN0LCBcInN1Y2Nlc3NcIikucGlwZShcbiAgICAgICAgICAvKiBTdG9wIHRoZSBgT2JzZXJ2YWJsZWAgd2hlbiB0aGUgY3Vyc29yIGlzIGBudWxsYCAqL1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByeGpzL25vLWlnbm9yZWQtdGFrZXdoaWxlLXZhbHVlIC0tIFJlcXVpcmVkIGJ5IGluZGV4ZWREYiBiZWhhdmlvciwgZ2V0dGluZyB0aGUgcmVzdWx0IGZyb20gdGhlIGV2ZW50IGRvZXMgbm90IGFsd2F5cyB3b3JrXG4gICAgICAgICAgdGFrZVdoaWxlKCgpID0+IChyZXF1ZXN0LnJlc3VsdCAhPT0gbnVsbCkpLFxuICAgICAgICAgIC8qIFRoaXMgbGliIG9ubHkgYWxsb3dzIHN0cmluZyBrZXlzLCBidXQgdXNlciBjb3VsZCBoYXZlIGFkZGVkIG90aGVyIHR5cGVzIG9mIGtleXMgZnJvbSBvdXRzaWRlXG4gICAgICAgICAgICogSXQncyBPSyB0byBjYXN0IGFzIHRoZSBjdXJzb3IgYXMgYmVlbiB0ZXN0ZWQgaW4gdGhlIHByZXZpb3VzIG9wZXJhdG9yICovXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1iYXNlLXRvLXN0cmluZyAtLSBSZXF1aXJlZCBieSBpbmRleGVkRGIgYmVoYXZpb3IsIGFuZCBzdHJpbmdzIGFyZSBlbmZvcmNlZCBieSB0aGUgbGliXG4gICAgICAgICAgbWFwKCgpID0+IHJlcXVlc3QucmVzdWx0IS5rZXkudG9TdHJpbmcoKSksXG4gICAgICAgICAgLyogSXRlcmF0ZSBvbiB0aGUgY3Vyc29yICovXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gUmVxdWlyZWQgYnkgaW5kZXhlZERiIGJlaGF2aW9yXG4gICAgICAgICAgdGFwKCgpID0+IHsgcmVxdWVzdC5yZXN1bHQhLmNvbnRpbnVlKCk7IH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBlcnJvciBldmVudCBhbmQgaWYgc28sIHRocm93IGFuIGVycm9yICovXG4gICAgICAgIGNvbnN0IGVycm9yJCA9IHRoaXMubGlzdGVuRXJyb3IocmVxdWVzdCk7XG5cbiAgICAgICAgLyogQ2hvb3NlIHRoZSBmaXJzdCBldmVudCB0byBvY2N1ciAqL1xuICAgICAgICByZXR1cm4gcmFjZShbc3VjY2VzcyQsIGVycm9yJF0pO1xuXG4gICAgICB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgZXhpc3RzIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcmV0dXJucyBBbiBSeEpTIGBPYnNlcnZhYmxlYCB0ZWxsaW5nIGlmIHRoZSBrZXkgZXhpc3RzIG9yIG5vdFxuICAgKi9cbiAgaGFzKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbihcInJlYWRvbmx5XCIpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogQ2hlY2sgaWYgdGhlIGtleSBleGlzdHMgaW4gdGhlIHN0b3JlXG4gICAgICAgICAqIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzY5XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0S2V5KGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGV2ZW50cyBhbmQgcmV0dXJuIGB0cnVlYCBvciBgZmFsc2VgICovXG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXAoKCkgPT4gKHJlcXVlc3QucmVzdWx0ICE9PSB1bmRlZmluZWQpID8gdHJ1ZSA6IGZhbHNlKSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gYGluZGV4ZWREQmAgYW5kIGNyZWF0ZXMgdGhlIG9iamVjdCBzdG9yZSBvbiBmaXJzdCB0aW1lXG4gICAqL1xuICBwcml2YXRlIGNvbm5lY3QoKTogdm9pZCB7XG5cbiAgICBsZXQgcmVxdWVzdDogSURCT3BlbkRCUmVxdWVzdDtcblxuICAgIC8qIENvbm5lY3QgdG8gYGluZGV4ZWREQmBcbiAgICAgKiBXaWxsIGZhaWwgaW4gU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNDJ9ICovXG4gICAgdHJ5IHtcblxuICAgICAgLyogRG8gTk9UIGV4cGxpY2l0IGB3aW5kb3dgIGhlcmUsIGFzIGBpbmRleGVkREJgIGNvdWxkIGJlIHVzZWQgZnJvbSBhIHdlYiB3b3JrZXIgdG9vICovXG4gICAgICByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4odGhpcy5kYk5hbWUsIHRoaXMuZGJWZXJzaW9uKTtcblxuICAgIH0gY2F0Y2gge1xuXG4gICAgICB0aGlzLmRhdGFiYXNlLmVycm9yKG5ldyBJREJCcm9rZW5FcnJvcigpKTtcblxuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgLyogQ3JlYXRlIHN0b3JlIG9uIGZpcnN0IGNvbm5lY3Rpb24gKi9cbiAgICB0aGlzLmNyZWF0ZVN0b3JlKHJlcXVlc3QpO1xuXG4gICAgLyogTGlzdGVuIHRvIHN1Y2Nlc3MgYW5kIGVycm9yIGV2ZW50cyAqL1xuICAgIGNvbnN0IHN1Y2Nlc3MkID0gZnJvbUV2ZW50KHJlcXVlc3QsIFwic3VjY2Vzc1wiKTtcbiAgICBjb25zdCBlcnJvciQgPSB0aGlzLmxpc3RlbkVycm9yKHJlcXVlc3QpO1xuXG4gICAgLyogQ2hvb3NlIHRoZSBmaXJzdCB0byBvY2N1ciAqL1xuICAgIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKVxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgLyogUmVnaXN0ZXIgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gaW4gdGhlIGBSZXBsYXlTdWJqZWN0YCBmb3IgZnVydGhlciBhY2Nlc3MgKi9cbiAgICAgICAgICB0aGlzLmRhdGFiYXNlLm5leHQocmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge1xuICAgICAgICAgIC8qIEtlZXBpbmcgdGhpcyBlcnJvciBtYW5hZ2VtZW50IGZvciBzYWZldHksIGJ1dCBpdCBzaG91bGQgbm90IGhhcHBlbiBhbnltb3JlLlxuICAgICAgICAgICAqIEl0IHdhcyBmb3IgRmlyZWZveCBwcml2YXRlIG1vZGUgaXNzdWUgaW4gRmlyZWZveCB2ZXJzaW9ucyA8IDExNVxuICAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzI2fSAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UuZXJyb3IobmV3IElEQkJyb2tlbkVycm9yKCkpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgc3RvcmUgb24gZmlyc3QgdXNlIG9mIGBpbmRleGVkREJgXG4gICAqIEBwYXJhbSByZXF1ZXN0IGBpbmRleGVkREJgIGRhdGFiYXNlIG9wZW5pbmcgcmVxdWVzdFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVTdG9yZShyZXF1ZXN0OiBJREJPcGVuREJSZXF1ZXN0KTogdm9pZCB7XG5cbiAgICAvKiBMaXN0ZW4gdG8gdGhlIGV2ZW50IGZpcmVkIG9uIGZpcnN0IGNvbm5lY3Rpb24gKi9cbiAgICBmcm9tRXZlbnQocmVxdWVzdCwgXCJ1cGdyYWRlbmVlZGVkXCIpXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlICovXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICgpID0+IHtcblxuICAgICAgICAgIC8qIENoZWNrIGlmIHRoZSBzdG9yZSBhbHJlYWR5IGV4aXN0cywgdG8gYXZvaWQgZXJyb3IgKi9cbiAgICAgICAgICBpZiAoIXJlcXVlc3QucmVzdWx0Lm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGhpcy5zdG9yZU5hbWUpKSB7XG5cbiAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgb2JqZWN0IHN0b3JlICovXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGFuIGBpbmRleGVkREJgIHRyYW5zYWN0aW9uIGFuZCBnZXQgb3VyIHN0b3JlXG4gICAqIEBwYXJhbSBtb2RlIGByZWFkb25seWAgb3IgYHJlYWR3cml0ZWBcbiAgICogQHJldHVybnMgQW4gYGluZGV4ZWREQmAgdHJhbnNhY3Rpb24gc3RvcmUgYW5kIGV2ZW50cywgd3JhcHBlZCBpbiBhbiBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKi9cbiAgcHJpdmF0ZSB0cmFuc2FjdGlvbihtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUpOiBPYnNlcnZhYmxlPHtcbiAgICBzdG9yZTogSURCT2JqZWN0U3RvcmU7XG4gICAgZXZlbnRzOiBPYnNlcnZhYmxlPEV2ZW50PjtcbiAgfT4ge1xuXG4gICAgLyogRnJvbSB0aGUgYGluZGV4ZWREQmAgY29ubmVjdGlvbiwgb3BlbiBhIHRyYW5zYWN0aW9uIGFuZCBnZXQgdGhlIHN0b3JlICovXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2VcbiAgICAgIC5waXBlKG1lcmdlTWFwKChkYXRhYmFzZSkgPT4ge1xuXG4gICAgICAgIGxldCB0cmFuc2FjdGlvbjogSURCVHJhbnNhY3Rpb247XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgIHRyYW5zYWN0aW9uID0gZGF0YWJhc2UudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgbW9kZSk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgICAgIC8qIFRoZSBzdG9yZSBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZCBmcm9tIG91dHNpZGUgKi9cbiAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBlcnJvciBhcyBET01FeGNlcHRpb24pO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBHZXQgdGhlIHN0b3JlIGZyb20gdGhlIHRyYW5zYWN0aW9uICovXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0cmFuc2FjdGlvbiBgY29tcGxldGVgIGFuZCBgZXJyb3JgIGV2ZW50cyAqL1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLmxpc3RlblRyYW5zYWN0aW9uRXZlbnRzKHRyYW5zYWN0aW9uKTtcblxuICAgICAgICByZXR1cm4gb2YoeyBzdG9yZSwgZXZlbnRzIH0pO1xuXG4gICAgICB9KSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZXJyb3JzIG9uIGEgdHJhbnNhY3Rpb24gb3IgcmVxdWVzdCwgYW5kIHRocm93IGlmIHRyaWdlcnJlZFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25PclJlcXVlc3QgYGluZGV4ZWREYmAgdHJhbnNhY3Rpb24gb3IgcmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHJldHVybnMgQW4gYE9ic2VydmFibGVgIGxpc3RlbmluZyB0byBlcnJvcnNcbiAgICovXG4gIHByaXZhdGUgbGlzdGVuRXJyb3IodHJhbnNhY3Rpb25PclJlcXVlc3Q6IElEQlRyYW5zYWN0aW9uIHwgSURCUmVxdWVzdCk6IE9ic2VydmFibGU8bmV2ZXI+IHtcblxuICAgIHJldHVybiBmcm9tRXZlbnQodHJhbnNhY3Rpb25PclJlcXVlc3QsIFwiZXJyb3JcIikucGlwZShcbiAgICAgIC8qIFRocm93IG9uIGVycm9yIHRvIGJlIGFibGUgdG8gY2F0Y2ggZXJyb3JzIGluIFJ4SlMgd2F5LlxuICAgICAgICogSGVyZSBgZXZlbnQudGFyZ2V0YCBtdXN0IGJlIHVzZWQsIGFzIGB0cmFuc2FjdGlvbk9yUmVxdWVzdC5lcnJvcmAgd2lsbCBiZSBgbnVsbGBcbiAgICAgICAqIGlmIHdlIGFyZSBvbiB0aGUgcmVxdWVzdCBhbmQgdGhlIGVycm9yIGlzIG9ubHkgdHJpZ2dlcmVkIGxhdGVyIGJ5IHRoZSB0cmFuc2FjdGlvbiAqL1xuICAgICAgbWVyZ2VNYXAoKGV2ZW50KSA9PiB0aHJvd0Vycm9yKCgpID0+IChldmVudC50YXJnZXQgYXMgSURCVHJhbnNhY3Rpb24gfCBJREJSZXF1ZXN0IHwgbnVsbCk/LmVycm9yKSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0cmFuc2FjdGlvbiBgY29tcGxldGVgIGFuZCBgZXJyb3JgIGV2ZW50c1xuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gbGlzdGVuXG4gICAqIEByZXR1cm5zIEFuIGBPYnNlcnZhYmxlYCBsaXN0ZW5pbmcgdG8gdHJhbnNhY3Rpb24gYGNvbXBsZXRlYCBhbmQgYGVycm9yYCBldmVudHNcbiAgICovXG4gIHByaXZhdGUgbGlzdGVuVHJhbnNhY3Rpb25FdmVudHModHJhbnNhY3Rpb246IElEQlRyYW5zYWN0aW9uKTogT2JzZXJ2YWJsZTxFdmVudD4ge1xuXG4gICAgLyogTGlzdGVuIHRvIHRoZSBgY29tcGxldGVgIGV2ZW50ICovXG4gICAgY29uc3QgY29tcGxldGUkID0gZnJvbUV2ZW50KHRyYW5zYWN0aW9uLCBcImNvbXBsZXRlXCIpO1xuXG4gICAgLyogTGlzdGVuIHRvIHRoZSBgZXJyb3JgIGV2ZW50ICovXG4gICAgY29uc3QgZXJyb3IkID0gdGhpcy5saXN0ZW5FcnJvcih0cmFuc2FjdGlvbik7XG5cbiAgICAvKiBDaG9vc2UgdGhlIGZpcnN0IGV2ZW50IHRvIG9jY3VyICovXG4gICAgcmV0dXJuIHJhY2UoW2NvbXBsZXRlJCwgZXJyb3IkXSk7XG5cbiAgfVxuXG59XG4iXX0=