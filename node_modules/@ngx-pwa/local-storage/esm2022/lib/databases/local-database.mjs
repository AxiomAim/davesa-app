import { isPlatformBrowser } from "@angular/common";
import { inject, Injectable, PLATFORM_ID } from "@angular/core";
import { Observable } from "rxjs";
import { IndexedDBDatabase } from "./indexeddb-database";
import { LocalStorageDatabase } from "./localstorage-database";
import { MemoryDatabase } from "./memory-database";
import * as i0 from "@angular/core";
/**
 * Factory to create a storage according to browser support
 * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}
 */
export function localDatabaseFactory() {
    const platformId = inject(PLATFORM_ID);
    /* When storage is fully disabled in browser (via the "Block all cookies" option),
     * just trying to check `indexedDB` or `localStorage` variables causes a security exception.
     * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
     */
    try {
        // Do not explicit `window` here, as the global object is not the same in web workers
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios
        if (isPlatformBrowser(platformId) && (indexedDB !== undefined) && (indexedDB !== null) && ("open" in indexedDB)) {
            /* Check:
            * - if we are in a browser context (issue: server-side rendering)
            * - it could exist but be `undefined` or `null`
            * - it could exists but not having a working API
            * Will be the case for:
            * - All other browsers in normal mode
            * - Chromium / Safari / Firefox private mode, but in this case, data will be swiped when the user leaves the app */
            return new IndexedDBDatabase();
        }
        else if (isPlatformBrowser(platformId)
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios
            && (localStorage !== undefined) && (localStorage !== null) && ("getItem" in localStorage)) {
            /* Check:
            * - if we are in a browser context (issue: server-side rendering)
            * - if `localStorage` exists (to be sure)
            * - it could exists but not having a working API
            * Will be the case for:
            * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`
            * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}
            */
            return new LocalStorageDatabase();
        }
    }
    catch {
        // Nothing to do
    }
    /* Will be the case for:
     * - In browsers if storage has been fully disabled (via the "Block all cookies" option)
     * - Server-side rendering
     * - All other non-browser context
     */
    return new MemoryDatabase();
}
export class LocalDatabase {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: LocalDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: LocalDatabase, providedIn: "root", useFactory: localDatabaseFactory }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: LocalDatabase, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root",
                    useFactory: localDatabaseFactory,
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWwtZGF0YWJhc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWIvc3JjL2xpYi9kYXRhYmFzZXMvbG9jYWwtZGF0YWJhc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDekQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDOztBQUVuRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsb0JBQW9CO0lBRWxDLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUV2Qzs7O09BR0c7SUFDSCxJQUFJLENBQUM7UUFFSCxxRkFBcUY7UUFDckYsMkhBQTJIO1FBQzNILElBQUksaUJBQWlCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUVoSDs7Ozs7OytIQU1tSDtZQUNuSCxPQUFPLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUVqQyxDQUFDO2FBQU0sSUFBSSxpQkFBaUIsQ0FBQyxVQUFVLENBQUM7WUFDdEMsMkhBQTJIO2VBQ3hILENBQUMsWUFBWSxLQUFLLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLFlBQVksQ0FBQyxFQUFFLENBQUM7WUFFNUY7Ozs7Ozs7Y0FPRTtZQUNGLE9BQU8sSUFBSSxvQkFBb0IsRUFBRSxDQUFDO1FBRXBDLENBQUM7SUFFSCxDQUFDO0lBQUMsTUFBTSxDQUFDO1FBQ1AsZ0JBQWdCO0lBQ2xCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTyxJQUFJLGNBQWMsRUFBRSxDQUFDO0FBRTlCLENBQUM7QUFNRCxNQUFNLE9BQWdCLGFBQWE7OEdBQWIsYUFBYTtrSEFBYixhQUFhLGNBSHJCLE1BQU0sY0FDTixvQkFBb0I7OzJGQUVaLGFBQWE7a0JBSmxDLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07b0JBQ2xCLFVBQVUsRUFBRSxvQkFBb0I7aUJBQ2pDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uXCI7XG5pbXBvcnQgeyBpbmplY3QsIEluamVjdGFibGUsIFBMQVRGT1JNX0lEIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgSW5kZXhlZERCRGF0YWJhc2UgfSBmcm9tIFwiLi9pbmRleGVkZGItZGF0YWJhc2VcIjtcbmltcG9ydCB7IExvY2FsU3RvcmFnZURhdGFiYXNlIH0gZnJvbSBcIi4vbG9jYWxzdG9yYWdlLWRhdGFiYXNlXCI7XG5pbXBvcnQgeyBNZW1vcnlEYXRhYmFzZSB9IGZyb20gXCIuL21lbW9yeS1kYXRhYmFzZVwiO1xuXG4vKipcbiAqIEZhY3RvcnkgdG8gY3JlYXRlIGEgc3RvcmFnZSBhY2NvcmRpbmcgdG8gYnJvd3NlciBzdXBwb3J0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL0JST1dTRVJTX1NVUFBPUlQubWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbERhdGFiYXNlRmFjdG9yeSgpOiBMb2NhbERhdGFiYXNlIHtcblxuICBjb25zdCBwbGF0Zm9ybUlkID0gaW5qZWN0KFBMQVRGT1JNX0lEKTtcblxuICAvKiBXaGVuIHN0b3JhZ2UgaXMgZnVsbHkgZGlzYWJsZWQgaW4gYnJvd3NlciAodmlhIHRoZSBcIkJsb2NrIGFsbCBjb29raWVzXCIgb3B0aW9uKSxcbiAgICoganVzdCB0cnlpbmcgdG8gY2hlY2sgYGluZGV4ZWREQmAgb3IgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGVzIGNhdXNlcyBhIHNlY3VyaXR5IGV4Y2VwdGlvbi5cbiAgICogUHJldmVudHMgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvMTE4XG4gICAqL1xuICB0cnkge1xuXG4gICAgLy8gRG8gbm90IGV4cGxpY2l0IGB3aW5kb3dgIGhlcmUsIGFzIHRoZSBnbG9iYWwgb2JqZWN0IGlzIG5vdCB0aGUgc2FtZSBpbiB3ZWIgd29ya2Vyc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uIC0tIFRoZXkgY2FuIGJlIHVuZGVmaW5lZCBpbiBzb21lIGJyb3dzZXJzIHNjZW5hcmlvc1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3NlcihwbGF0Zm9ybUlkKSAmJiAoaW5kZXhlZERCICE9PSB1bmRlZmluZWQpICYmIChpbmRleGVkREIgIT09IG51bGwpICYmIChcIm9wZW5cIiBpbiBpbmRleGVkREIpKSB7XG5cbiAgICAgIC8qIENoZWNrOlxuICAgICAgKiAtIGlmIHdlIGFyZSBpbiBhIGJyb3dzZXIgY29udGV4dCAoaXNzdWU6IHNlcnZlci1zaWRlIHJlbmRlcmluZylcbiAgICAgICogLSBpdCBjb3VsZCBleGlzdCBidXQgYmUgYHVuZGVmaW5lZGAgb3IgYG51bGxgXG4gICAgICAqIC0gaXQgY291bGQgZXhpc3RzIGJ1dCBub3QgaGF2aW5nIGEgd29ya2luZyBBUElcbiAgICAgICogV2lsbCBiZSB0aGUgY2FzZSBmb3I6XG4gICAgICAqIC0gQWxsIG90aGVyIGJyb3dzZXJzIGluIG5vcm1hbCBtb2RlXG4gICAgICAqIC0gQ2hyb21pdW0gLyBTYWZhcmkgLyBGaXJlZm94IHByaXZhdGUgbW9kZSwgYnV0IGluIHRoaXMgY2FzZSwgZGF0YSB3aWxsIGJlIHN3aXBlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGUgYXBwICovXG4gICAgICByZXR1cm4gbmV3IEluZGV4ZWREQkRhdGFiYXNlKCk7XG5cbiAgICB9IGVsc2UgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBUaGV5IGNhbiBiZSB1bmRlZmluZWQgaW4gc29tZSBicm93c2VycyBzY2VuYXJpb3NcbiAgICAgICYmIChsb2NhbFN0b3JhZ2UgIT09IHVuZGVmaW5lZCkgJiYgKGxvY2FsU3RvcmFnZSAhPT0gbnVsbCkgJiYgKFwiZ2V0SXRlbVwiIGluIGxvY2FsU3RvcmFnZSkpIHtcblxuICAgICAgLyogQ2hlY2s6XG4gICAgICAqIC0gaWYgd2UgYXJlIGluIGEgYnJvd3NlciBjb250ZXh0IChpc3N1ZTogc2VydmVyLXNpZGUgcmVuZGVyaW5nKVxuICAgICAgKiAtIGlmIGBsb2NhbFN0b3JhZ2VgIGV4aXN0cyAodG8gYmUgc3VyZSlcbiAgICAgICogLSBpdCBjb3VsZCBleGlzdHMgYnV0IG5vdCBoYXZpbmcgYSB3b3JraW5nIEFQSVxuICAgICAgKiBXaWxsIGJlIHRoZSBjYXNlIGZvcjpcbiAgICAgICogLSBTYWZhcmkgY3Jvc3Mtb3JpZ2luIGlmcmFtZXMsIGRldGVjdGVkIGxhdGVyIGluIGBJbmRleGVkREJEYXRhYmFzZS5jb25uZWN0KClgXG4gICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzQyfVxuICAgICAgKi9cbiAgICAgIHJldHVybiBuZXcgTG9jYWxTdG9yYWdlRGF0YWJhc2UoKTtcblxuICAgIH1cblxuICB9IGNhdGNoIHtcbiAgICAvLyBOb3RoaW5nIHRvIGRvXG4gIH1cblxuICAvKiBXaWxsIGJlIHRoZSBjYXNlIGZvcjpcbiAgICogLSBJbiBicm93c2VycyBpZiBzdG9yYWdlIGhhcyBiZWVuIGZ1bGx5IGRpc2FibGVkICh2aWEgdGhlIFwiQmxvY2sgYWxsIGNvb2tpZXNcIiBvcHRpb24pXG4gICAqIC0gU2VydmVyLXNpZGUgcmVuZGVyaW5nXG4gICAqIC0gQWxsIG90aGVyIG5vbi1icm93c2VyIGNvbnRleHRcbiAgICovXG4gIHJldHVybiBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46IFwicm9vdFwiLFxuICB1c2VGYWN0b3J5OiBsb2NhbERhdGFiYXNlRmFjdG9yeSxcbn0pXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTG9jYWxEYXRhYmFzZSB7XG5cbiAgYWJzdHJhY3QgcmVhZG9ubHkgc2l6ZTogT2JzZXJ2YWJsZTxudW1iZXI+O1xuXG4gIGFic3RyYWN0IGdldChrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5rbm93bj47XG4gIGFic3RyYWN0IHNldChrZXk6IHN0cmluZywgZGF0YTogdW5rbm93bik6IE9ic2VydmFibGU8dW5kZWZpbmVkPjtcbiAgYWJzdHJhY3QgZGVsZXRlKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+O1xuICBhYnN0cmFjdCBjbGVhcigpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD47XG4gIGFic3RyYWN0IGtleXMoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICBhYnN0cmFjdCBoYXMoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuXG59XG4iXX0=