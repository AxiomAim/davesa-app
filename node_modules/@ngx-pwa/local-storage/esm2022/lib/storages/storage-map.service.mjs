import { Injectable } from "@angular/core";
import { Observable, ReplaySubject, of, throwError } from "rxjs";
import { catchError, mergeMap, tap } from "rxjs/operators";
import { IDB_BROKEN_ERROR } from "../databases/exceptions";
import { IndexedDBDatabase } from "../databases/indexeddb-database";
import { LocalDatabase } from "../databases/local-database";
import { LocalStorageDatabase } from "../databases/localstorage-database";
import { MemoryDatabase } from "../databases/memory-database";
import { JSONValidator } from "../validation/json-validator";
import { ValidationError } from "./exceptions";
import * as i0 from "@angular/core";
import * as i1 from "../databases/local-database";
export class StorageMap {
    #database;
    #jsonValidator;
    #notifiers = new Map();
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param database Storage to use
     */
    constructor(database) {
        this.#database = database;
        this.#jsonValidator = new JSONValidator();
    }
    /**
     * **Number of items** in storage, wrapped in an Observable.
     *
     * Note you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @example
     * this.storageMap.size.subscribe((size) => {
     *   console.log(size);
     * });
     */
    get size() {
        return this.#database.size
            /* Catch if `indexedDb` is broken */
            .pipe(this.#catchIDBBroken(() => this.#database.size));
    }
    /**
     * Tells you which storage engine is used.
     *
     * *Only useful for interoperability.*
     *
     * Note that due to some browsers issues in some special contexts
     * (like Safari cross-origin iframes),
     * **this information may be wrong at initialization,**
     * as the storage could fallback from `indexedDB` to `localStorage`
     * only after a first read or write operation.
     * @returns Storage engine used
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {}
     */
    get backingEngine() {
        if (this.#database instanceof IndexedDBDatabase) {
            return "indexedDB";
        }
        else if (this.#database instanceof LocalStorageDatabase) {
            return "localStorage";
        }
        else if (this.#database instanceof MemoryDatabase) {
            return "memory";
        }
        else {
            return "unknown";
        }
    }
    /**
     * Information about `indexedDB` database.
     *
     * *Only useful for interoperability.*
     *
     * @returns `indexedDB` database name, store name and database version.
     * **Values will be empty if the storage is not `indexedDB`, so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {
     *   const { database, store, version } = this.storageMap.backingStore;
     * }
     */
    get backingStore() {
        return (this.#database instanceof IndexedDBDatabase) ?
            this.#database.backingStore :
            { database: "", store: "", version: 0 };
    }
    /**
     * Information about `localStorage` fallback storage.
     *
     * *Only useful for interoperability.*
     *
     * @returns `localStorage` prefix.
     * **Values will be empty if the storage is not `localStorage`, so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'localStorage') {
     *   const { prefix } = this.storageMap.fallbackBackingStore;
     * }
     */
    get fallbackBackingStore() {
        return (this.#database instanceof LocalStorageDatabase) ?
            { prefix: this.#database.prefix } :
            { prefix: "" };
    }
    get(key, schema) {
        /* Get the data in storage */
        return this.#database.get(key).pipe(
        /* Check if `indexedDb` is broken */
        this.#catchIDBBroken(() => this.#database.get(key)), mergeMap((data) => {
            /* No need to validate if the data is empty */
            if ((data === undefined) || (data === null)) {
                return of(undefined);
            }
            else if (schema) {
                /* Validate data against a JSON schema if provided */
                if (!this.#jsonValidator.validate(data, schema)) {
                    return throwError(() => new ValidationError());
                }
                /* Data have been checked, so it's OK to cast */
                return of(data);
            }
            /* Cast to unknown as the data wasn't checked */
            return of(data);
        }));
    }
    /**
     * Store an item in storage.
     *
     * Note that:
     * * you *do* need to subscribe, even if you do not have something specific to do after writing in storage, otherwise nothing happens (because it is how RxJS Observables work),
     * * but you do *not* need to unsubscribe (it is a self-completing Observable),
     * * setting `null` or `undefined` will remove the item to avoid some browsers issues,
     * * you should stick to serializable JSON data, meaning primitive types, arrays and literal objects. Date, Map, Set, Blob and other special structures can cause issues in some scenarios.
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/SERIALIZATION.md}
     *
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS Observable to wait the end of the operation
     *
     * @example
     * this.storageMap.set('key', 'value').subscribe(() => {});
     */
    set(key, data, schema) {
        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,
         * so removing item instead for all storages to have a consistent API */
        if ((data === undefined) || (data === null)) {
            return this.delete(key);
        }
        /* Validate data against a JSON schema if provided */
        if (schema && !this.#jsonValidator.validate(data, schema)) {
            return throwError(() => new ValidationError());
        }
        return this.#database.set(key, data).pipe(
        /* Catch if `indexedDb` is broken */
        this.#catchIDBBroken(() => this.#database.set(key, data)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.#notify(key, data); }));
    }
    /**
     * Delete an item in storage.
     *
     * Note that:
     * * you *do* need to subscribe, even if you do not have something specific to do after deleting, otherwise nothing happens (because it is how RxJS Observables work),
     * * but you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @param key The item's key
     * @returns A RxJS Observable to wait the end of the operation
     *
     * @example
     * this.storageMap.delete('key').subscribe(() => {});
     */
    delete(key) {
        return this.#database.delete(key).pipe(
        /* Catch if `indexedDb` is broken */
        this.#catchIDBBroken(() => this.#database.delete(key)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.#notify(key, undefined); }));
    }
    /**
     * Delete all items in storage.
     *
     * Note that:
     * * you *do* need to subscribe, even if you do not have something specific to do after clearing, otherwise nothing happens (because it is how RxJS Observables work),
     * * but you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @returns A RxJS Observable to wait the end of the operation
     *
     * @example
     * this.storageMap.clear().subscribe(() => {});
     */
    clear() {
        return this.#database.clear().pipe(
        /* Catch if `indexedDb` is broken */
        this.#catchIDBBroken(() => this.#database.clear()), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => {
            for (const key of this.#notifiers.keys()) {
                this.#notify(key, undefined);
            }
        }));
    }
    /**
     * Get all keys stored in storage.
     *
     * Note **this is an *iterating* Observable**:
     * * if there is no key, the `next` callback will not be invoked,
     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,
     * as this Observable can emit several values and so will invoke the `next` callback several times,
     * * you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @returns A list of the keys wrapped in a RxJS Observable
     *
     * @example
     * this.storageMap.keys().subscribe({
     *   next: (key) => { console.log(key); },
     *   complete: () => { console.log('Done'); },
     * });
     */
    keys() {
        return this.#database.keys()
            /* Catch if `indexedDb` is broken */
            .pipe(this.#catchIDBBroken(() => this.#database.keys()));
    }
    /**
     * Tells if a key exists in storage.
     *
     * Note you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @returns A RxJS Observable telling if the key exists
     *
     * @example
     * this.storageMap.has('key').subscribe((hasKey) => {
     *   if (hasKey) {}
     * });
     */
    has(key) {
        return this.#database.has(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.#catchIDBBroken(() => this.#database.has(key)));
    }
    watch(key, schema) {
        /* Check if there is already a notifier */
        if (!this.#notifiers.has(key)) {
            this.#notifiers.set(key, new ReplaySubject(1));
        }
        /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Ensured by the logic
        const notifier = this.#notifiers.get(key);
        /* Get the current item value */
        (schema ? this.get(key, schema) : this.get(key)).subscribe({
            next: (result) => {
                notifier.next(result);
            },
            error: (error) => {
                notifier.error(error);
            },
        });
        /* Only the public API of the Observable should be returned */
        return (schema ?
            notifier.asObservable() :
            notifier.asObservable());
    }
    /**
     * Notify when a value changes
     * @param key The item's key
     * @param data The new value
     */
    #notify(key, value) {
        const notifier = this.#notifiers.get(key);
        if (notifier) {
            notifier.next(value);
        }
    }
    /**
     * RxJS operator to catch if `indexedDB` is broken
     * @param operationCallback Callback with the operation to redo
     */
    #catchIDBBroken(operationCallback) {
        return catchError((error) => {
            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */
            if ((error !== undefined) && (error !== null)
                && (typeof error === "object") && ("message" in error)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- Required because TypeScript narrowing is not working here
                && (error.message === IDB_BROKEN_ERROR)) {
                /* When storage is fully disabled in browser (via the "Block all cookies" option),
                 * just trying to check `localStorage` variable causes a security exception.
                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
                 */
                try {
                    if ("getItem" in localStorage) {
                        /* Fallback to `localStorage` if available */
                        this.#database = new LocalStorageDatabase();
                    }
                    else {
                        /* Fallback to memory storage otherwise */
                        this.#database = new MemoryDatabase();
                    }
                }
                catch {
                    /* Fallback to memory storage otherwise */
                    this.#database = new MemoryDatabase();
                }
                /* Redo the operation */
                return operationCallback();
            }
            else {
                /* Otherwise, rethrow the error */
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return throwError(() => error);
            }
        });
    }
    /**
     * THIS METHOD IS FOR INTERNAL PURPOSE ONLY AND MUST NOT BE USED,
     * IT CAN BE REMOVED AT ANY TIME AND MESSING WITH IT CAN CAUSE ISSUES
     * @private
     * @ignore
     */
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment, @typescript-eslint/prefer-ts-expect-error -- Silence the not used error, it is used in tests
    // @ts-ignore
    ɵinternalGetDatabase() {
        return this.#database;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: StorageMap, deps: [{ token: i1.LocalDatabase }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: StorageMap, providedIn: "root" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.0", ngImport: i0, type: StorageMap, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: "root"
                }]
        }], ctorParameters: () => [{ type: i1.LocalDatabase }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS1tYXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYi9zcmMvbGliL3N0b3JhZ2VzL3N0b3JhZ2UtbWFwLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUF5QixNQUFNLE1BQU0sQ0FBQztBQUN4RixPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNwRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDNUQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDMUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBTzlELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUM3RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7QUFLL0MsTUFBTSxPQUFPLFVBQVU7SUFFckIsU0FBUyxDQUFnQjtJQUNoQixjQUFjLENBQWdCO0lBQzlCLFVBQVUsR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQUVoRTs7O09BR0c7SUFDSCxZQUNFLFFBQXVCO1FBRXZCLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1FBQzFCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxhQUFhLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsSUFBSSxJQUFJO1FBRU4sT0FBTyxJQUFJ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Y29yZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCwgb2YsIHRocm93RXJyb3IsIHR5cGUgT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtZXJnZU1hcCwgdGFwIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCI7XG5pbXBvcnQgeyBJREJfQlJPS0VOX0VSUk9SIH0gZnJvbSBcIi4uL2RhdGFiYXNlcy9leGNlcHRpb25zXCI7XG5pbXBvcnQgeyBJbmRleGVkREJEYXRhYmFzZSB9IGZyb20gXCIuLi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlXCI7XG5pbXBvcnQgeyBMb2NhbERhdGFiYXNlIH0gZnJvbSBcIi4uL2RhdGFiYXNlcy9sb2NhbC1kYXRhYmFzZVwiO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlRGF0YWJhc2UgfSBmcm9tIFwiLi4vZGF0YWJhc2VzL2xvY2Fsc3RvcmFnZS1kYXRhYmFzZVwiO1xuaW1wb3J0IHsgTWVtb3J5RGF0YWJhc2UgfSBmcm9tIFwiLi4vZGF0YWJhc2VzL21lbW9yeS1kYXRhYmFzZVwiO1xuaW1wb3J0IHR5cGUge1xuICBKU09OU2NoZW1hLFxuICBKU09OU2NoZW1hQXJyYXlPZixcbiAgSlNPTlNjaGVtYUJvb2xlYW4sIEpTT05TY2hlbWFJbnRlZ2VyLFxuICBKU09OU2NoZW1hTnVtYmVyLCBKU09OU2NoZW1hU3RyaW5nXG59IGZyb20gXCIuLi92YWxpZGF0aW9uL2pzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyBKU09OVmFsaWRhdG9yIH0gZnJvbSBcIi4uL3ZhbGlkYXRpb24vanNvbi12YWxpZGF0b3JcIjtcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gXCIuL2V4Y2VwdGlvbnNcIjtcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiBcInJvb3RcIlxufSlcbmV4cG9ydCBjbGFzcyBTdG9yYWdlTWFwIHtcblxuICAjZGF0YWJhc2U6IExvY2FsRGF0YWJhc2U7XG4gIHJlYWRvbmx5ICNqc29uVmFsaWRhdG9yOiBKU09OVmFsaWRhdG9yO1xuICByZWFkb25seSAjbm90aWZpZXJzID0gbmV3IE1hcDxzdHJpbmcsIFJlcGxheVN1YmplY3Q8dW5rbm93bj4+KCk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIHBhcmFtcyBhcmUgcHJvdmlkZWQgYnkgQW5ndWxhciAoYnV0IGNhbiBhbHNvIGJlIHBhc3NlZCBtYW51YWxseSBpbiB0ZXN0cylcbiAgICogQHBhcmFtIGRhdGFiYXNlIFN0b3JhZ2UgdG8gdXNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBkYXRhYmFzZTogTG9jYWxEYXRhYmFzZSxcbiAgKSB7XG4gICAgdGhpcy4jZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgICB0aGlzLiNqc29uVmFsaWRhdG9yID0gbmV3IEpTT05WYWxpZGF0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAqKk51bWJlciBvZiBpdGVtcyoqIGluIHN0b3JhZ2UsIHdyYXBwZWQgaW4gYW4gT2JzZXJ2YWJsZS5cbiAgICogXG4gICAqIE5vdGUgeW91IGRvICpub3QqIG5lZWQgdG8gdW5zdWJzY3JpYmUgKGl0IGlzIGEgc2VsZi1jb21wbGV0aW5nIE9ic2VydmFibGUpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuc2l6ZS5zdWJzY3JpYmUoKHNpemUpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzaXplKTtcbiAgICogfSk7XG4gICAqL1xuICBnZXQgc2l6ZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuI2RhdGFiYXNlLnNpemVcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy4jY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy4jZGF0YWJhc2Uuc2l6ZSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgeW91IHdoaWNoIHN0b3JhZ2UgZW5naW5lIGlzIHVzZWQuXG4gICAqIFxuICAgKiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBcbiAgICogTm90ZSB0aGF0IGR1ZSB0byBzb21lIGJyb3dzZXJzIGlzc3VlcyBpbiBzb21lIHNwZWNpYWwgY29udGV4dHNcbiAgICogKGxpa2UgU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzKSxcbiAgICogKip0aGlzIGluZm9ybWF0aW9uIG1heSBiZSB3cm9uZyBhdCBpbml0aWFsaXphdGlvbiwqKlxuICAgKiBhcyB0aGUgc3RvcmFnZSBjb3VsZCBmYWxsYmFjayBmcm9tIGBpbmRleGVkREJgIHRvIGBsb2NhbFN0b3JhZ2VgXG4gICAqIG9ubHkgYWZ0ZXIgYSBmaXJzdCByZWFkIG9yIHdyaXRlIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgU3RvcmFnZSBlbmdpbmUgdXNlZFxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL0lOVEVST1BFUkFCSUxJVFkubWR9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmICh0aGlzLnN0b3JhZ2VNYXAuYmFja2luZ0VuZ2luZSA9PT0gJ2luZGV4ZWREQicpIHt9XG4gICAqL1xuICBnZXQgYmFja2luZ0VuZ2luZSgpOiBcImluZGV4ZWREQlwiIHwgXCJsb2NhbFN0b3JhZ2VcIiB8IFwibWVtb3J5XCIgfCBcInVua25vd25cIiB7XG5cbiAgICBpZiAodGhpcy4jZGF0YWJhc2UgaW5zdGFuY2VvZiBJbmRleGVkREJEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gXCJpbmRleGVkREJcIjtcblxuICAgIH0gZWxzZSBpZiAodGhpcy4jZGF0YWJhc2UgaW5zdGFuY2VvZiBMb2NhbFN0b3JhZ2VEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gXCJsb2NhbFN0b3JhZ2VcIjtcblxuICAgIH0gZWxzZSBpZiAodGhpcy4jZGF0YWJhc2UgaW5zdGFuY2VvZiBNZW1vcnlEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gXCJtZW1vcnlcIjtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJldHVybiBcInVua25vd25cIjtcblxuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IGBpbmRleGVkREJgIGRhdGFiYXNlLlxuICAgKiBcbiAgICogKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogXG4gICAqIEByZXR1cm5zIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWUsIHN0b3JlIG5hbWUgYW5kIGRhdGFiYXNlIHZlcnNpb24uXG4gICAqICoqVmFsdWVzIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHN0b3JhZ2UgaXMgbm90IGBpbmRleGVkREJgLCBzbyBpdCBzaG91bGQgYmUgdXNlZCBhZnRlciBhbiBlbmdpbmUgY2hlY2sqKi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9JTlRFUk9QRVJBQklMSVRZLm1kfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAodGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdFbmdpbmUgPT09ICdpbmRleGVkREInKSB7XG4gICAqICAgY29uc3QgeyBkYXRhYmFzZSwgc3RvcmUsIHZlcnNpb24gfSA9IHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBiYWNraW5nU3RvcmUoKTogeyBkYXRhYmFzZTogc3RyaW5nLCBzdG9yZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXI7IH0ge1xuXG4gICAgcmV0dXJuICh0aGlzLiNkYXRhYmFzZSBpbnN0YW5jZW9mIEluZGV4ZWREQkRhdGFiYXNlKSA/XG4gICAgICB0aGlzLiNkYXRhYmFzZS5iYWNraW5nU3RvcmUgOlxuICAgICAgeyBkYXRhYmFzZTogXCJcIiwgc3RvcmU6IFwiXCIsIHZlcnNpb246IDAgfTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IGBsb2NhbFN0b3JhZ2VgIGZhbGxiYWNrIHN0b3JhZ2UuXG4gICAqIFxuICAgKiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBcbiAgICogQHJldHVybnMgYGxvY2FsU3RvcmFnZWAgcHJlZml4LlxuICAgKiAqKlZhbHVlcyB3aWxsIGJlIGVtcHR5IGlmIHRoZSBzdG9yYWdlIGlzIG5vdCBgbG9jYWxTdG9yYWdlYCwgc28gaXQgc2hvdWxkIGJlIHVzZWQgYWZ0ZXIgYW4gZW5naW5lIGNoZWNrKiouXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvSU5URVJPUEVSQUJJTElUWS5tZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nRW5naW5lID09PSAnbG9jYWxTdG9yYWdlJykge1xuICAgKiAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnN0b3JhZ2VNYXAuZmFsbGJhY2tCYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBmYWxsYmFja0JhY2tpbmdTdG9yZSgpOiB7IHByZWZpeDogc3RyaW5nOyB9IHtcblxuICAgIHJldHVybiAodGhpcy4jZGF0YWJhc2UgaW5zdGFuY2VvZiBMb2NhbFN0b3JhZ2VEYXRhYmFzZSkgP1xuICAgICAgeyBwcmVmaXg6IHRoaXMuI2RhdGFiYXNlLnByZWZpeCB9IDpcbiAgICAgIHsgcHJlZml4OiBcIlwiIH07XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaXRlbSB2YWx1ZSBpbiBzdG9yYWdlLlxuICAgKiBcbiAgICogTm90ZSB0aGF0OlxuICAgKiAqIG5vdCBmaW5kaW5nIGFuIGl0ZW0gaXMgbm90IGFuIGVycm9yLCBpdCBzdWNjZWVkcyBidXQgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICogKiB5b3UgZG8gKm5vdCogbmVlZCB0byB1bnN1YnNjcmliZSAoaXQgaXMgYSBzZWxmLWNvbXBsZXRpbmcgT2JzZXJ2YWJsZSksXG4gICAqICogeW91IHdpbGwgb25seSBnZXQgKm9uZSogdmFsdWU6IHRoZSBPYnNlcnZhYmxlIGlzIGhlcmUgZm9yIGFzeW5jaHJvbnkgYnV0IGlzICpub3QqIG1lYW50IHRvIGVtaXQgYWdhaW4gd2hlbiB0aGUgc3RvcmVkIGRhdGEgaXMgY2hhbmdlZC4gSWYgeW91IG5lZWQgdG8gd2F0Y2ggdGhlIHZhbHVlLCBzZWUgdGhlIGB3YXRjaGAgbWV0aG9kLlxuICAgKiBcbiAgICogRG8gbm90IGZvcmdldCBpdCBpcyBjbGllbnQtc2lkZSBzdG9yYWdlOiAqKmFsd2F5cyBjaGVjayB0aGUgZGF0YSoqLCBhcyBpdCBjb3VsZCBoYXZlIGJlZW4gZm9yZ2VkLlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqIFxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgYnV0IHJlY29tbWVuZGVkIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBkYXRhXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIGB1bmRlZmluZWRgIG90aGVyd2lzZSwgd3JhcHBlZCBpbiBhIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuZ2V0KCdrZXknLCB7IHR5cGU6ICdzdHJpbmcnIH0pLnN1YnNjcmliZSgocmVzdWx0KSA9PiB7XG4gICAqICAgcmVzdWx0OyAvLyBzdHJpbmcgb3IgdW5kZWZpbmVkXG4gICAqIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbnRlcmZhY2UgVXNlciB7XG4gICAqICAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAqICAgbGFzdE5hbWU/OiBzdHJpbmc7XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgc2NoZW1hID0ge1xuICAgKiAgIHR5cGU6ICdvYmplY3QnLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGZpcnN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgKiAgICAgbGFzdE5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICogICB9LFxuICAgKiAgIHJlcXVpcmVkOiBbJ2ZpcnN0TmFtZSddLFxuICAgKiB9IHNhdGlzZmllcyBKU09OU2NoZW1hO1xuICAgKlxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuZ2V0PFVzZXI+KCd1c2VyJywgc2NoZW1hKS5zdWJzY3JpYmUoKHVzZXIpID0+IHtcbiAgICogICBpZiAodXNlcikge1xuICAgKiAgICAgdXNlci5maXJzdE5hbWU7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICovXG4gIGdldChrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5rbm93bj47XG4gIGdldDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hU3RyaW5nKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgZXh0ZW5kcyBudW1iZXIgPSBudW1iZXI+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFJbnRlZ2VyIHwgSlNPTlNjaGVtYU51bWJlcik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFCb29sZWFuKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgZXh0ZW5kcyByZWFkb25seSBzdHJpbmdbXSA9IHN0cmluZ1tdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hU3RyaW5nPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzIC0tIEJldHRlciBmb3IgZG9jdW1lbnRhdGlvblxuICBnZXQ8VCBleHRlbmRzIHJlYWRvbmx5IG51bWJlcltdID0gbnVtYmVyW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFJbnRlZ2VyIHwgSlNPTlNjaGVtYU51bWJlcj4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlcyAtLSBCZXR0ZXIgZm9yIGRvY3VtZW50YXRpb25cbiAgZ2V0PFQgZXh0ZW5kcyByZWFkb25seSBib29sZWFuW10gPSBib29sZWFuW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFCb29sZWFuPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSB1bmtub3duPihrZXk6IHN0cmluZywgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5rbm93bj4ge1xuXG4gICAgLyogR2V0IHRoZSBkYXRhIGluIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy4jZGF0YWJhc2UuZ2V0KGtleSkucGlwZShcbiAgICAgIC8qIENoZWNrIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgdGhpcy4jY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy4jZGF0YWJhc2UuZ2V0KGtleSkpLFxuICAgICAgbWVyZ2VNYXAoKGRhdGEpID0+IHtcblxuICAgICAgICAvKiBObyBuZWVkIHRvIHZhbGlkYXRlIGlmIHRoZSBkYXRhIGlzIGVtcHR5ICovXG4gICAgICAgIGlmICgoZGF0YSA9PT0gdW5kZWZpbmVkKSB8fCAoZGF0YSA9PT0gbnVsbCkpIHtcblxuICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hKSB7XG5cbiAgICAgICAgICAvKiBWYWxpZGF0ZSBkYXRhIGFnYWluc3QgYSBKU09OIHNjaGVtYSBpZiBwcm92aWRlZCAqL1xuICAgICAgICAgIGlmICghdGhpcy4janNvblZhbGlkYXRvci52YWxpZGF0ZShkYXRhLCBzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcigoKSA9PiBuZXcgVmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIERhdGEgaGF2ZSBiZWVuIGNoZWNrZWQsIHNvIGl0J3MgT0sgdG8gY2FzdCAqL1xuICAgICAgICAgIHJldHVybiBvZihkYXRhIGFzIFQgfCB1bmRlZmluZWQpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBDYXN0IHRvIHVua25vd24gYXMgdGhlIGRhdGEgd2Fzbid0IGNoZWNrZWQgKi9cbiAgICAgICAgcmV0dXJuIG9mKGRhdGEpO1xuXG4gICAgICB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgYW4gaXRlbSBpbiBzdG9yYWdlLlxuICAgKiBcbiAgICogTm90ZSB0aGF0OlxuICAgKiAqIHlvdSAqZG8qIG5lZWQgdG8gc3Vic2NyaWJlLCBldmVuIGlmIHlvdSBkbyBub3QgaGF2ZSBzb21ldGhpbmcgc3BlY2lmaWMgdG8gZG8gYWZ0ZXIgd3JpdGluZyBpbiBzdG9yYWdlLCBvdGhlcndpc2Ugbm90aGluZyBoYXBwZW5zIChiZWNhdXNlIGl0IGlzIGhvdyBSeEpTIE9ic2VydmFibGVzIHdvcmspLFxuICAgKiAqIGJ1dCB5b3UgZG8gKm5vdCogbmVlZCB0byB1bnN1YnNjcmliZSAoaXQgaXMgYSBzZWxmLWNvbXBsZXRpbmcgT2JzZXJ2YWJsZSksXG4gICAqICogc2V0dGluZyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgd2lsbCByZW1vdmUgdGhlIGl0ZW0gdG8gYXZvaWQgc29tZSBicm93c2VycyBpc3N1ZXMsXG4gICAqICogeW91IHNob3VsZCBzdGljayB0byBzZXJpYWxpemFibGUgSlNPTiBkYXRhLCBtZWFuaW5nIHByaW1pdGl2ZSB0eXBlcywgYXJyYXlzIGFuZCBsaXRlcmFsIG9iamVjdHMuIERhdGUsIE1hcCwgU2V0LCBCbG9iIGFuZCBvdGhlciBzcGVjaWFsIHN0cnVjdHVyZXMgY2FuIGNhdXNlIGlzc3VlcyBpbiBzb21lIHNjZW5hcmlvcy5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9TRVJJQUxJWkFUSU9OLm1kfVxuICAgKiBcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgaXRlbSdzIHZhbHVlXG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIGRhdGFcbiAgICogQHJldHVybnMgQSBSeEpTIE9ic2VydmFibGUgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLnNldCgna2V5JywgJ3ZhbHVlJykuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIHNldChrZXk6IHN0cmluZywgZGF0YTogdW5rbm93biwgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBTdG9yaW5nIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpcyB1c2VsZXNzIGFuZCBjYW4gY2F1c2UgaXNzdWVzIGluIGBpbmRleGVkRGJgIGluIHNvbWUgYnJvd3NlcnMsXG4gICAgICogc28gcmVtb3ZpbmcgaXRlbSBpbnN0ZWFkIGZvciBhbGwgc3RvcmFnZXMgdG8gaGF2ZSBhIGNvbnNpc3RlbnQgQVBJICovXG4gICAgaWYgKChkYXRhID09PSB1bmRlZmluZWQpIHx8IChkYXRhID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgZGF0YSBhZ2FpbnN0IGEgSlNPTiBzY2hlbWEgaWYgcHJvdmlkZWQgKi9cbiAgICBpZiAoc2NoZW1hICYmICF0aGlzLiNqc29uVmFsaWRhdG9yLnZhbGlkYXRlKGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKCgpID0+IG5ldyBWYWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2RhdGFiYXNlLnNldChrZXksIGRhdGEpLnBpcGUoXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIHRoaXMuI2NhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuI2RhdGFiYXNlLnNldChrZXksIGRhdGEpKSxcbiAgICAgIC8qIE5vdGlmeSB3YXRjaGVycyAobXVzdCBiZSBsYXN0IGJlY2F1c2UgaXQgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBvcGVyYXRpb24gc3VjY2VlZHMpICovXG4gICAgICB0YXAoKCkgPT4geyB0aGlzLiNub3RpZnkoa2V5LCBkYXRhKTsgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYW4gaXRlbSBpbiBzdG9yYWdlLlxuICAgKiBcbiAgICogTm90ZSB0aGF0OlxuICAgKiAqIHlvdSAqZG8qIG5lZWQgdG8gc3Vic2NyaWJlLCBldmVuIGlmIHlvdSBkbyBub3QgaGF2ZSBzb21ldGhpbmcgc3BlY2lmaWMgdG8gZG8gYWZ0ZXIgZGVsZXRpbmcsIG90aGVyd2lzZSBub3RoaW5nIGhhcHBlbnMgKGJlY2F1c2UgaXQgaXMgaG93IFJ4SlMgT2JzZXJ2YWJsZXMgd29yayksXG4gICAqICogYnV0IHlvdSBkbyAqbm90KiBuZWVkIHRvIHVuc3Vic2NyaWJlIChpdCBpcyBhIHNlbGYtY29tcGxldGluZyBPYnNlcnZhYmxlKS5cbiAgICogXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQSBSeEpTIE9ic2VydmFibGUgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmRlbGV0ZSgna2V5Jykuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICByZXR1cm4gdGhpcy4jZGF0YWJhc2UuZGVsZXRlKGtleSkucGlwZShcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgdGhpcy4jY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy4jZGF0YWJhc2UuZGVsZXRlKGtleSkpLFxuICAgICAgLyogTm90aWZ5IHdhdGNoZXJzIChtdXN0IGJlIGxhc3QgYmVjYXVzZSBpdCBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIG9wZXJhdGlvbiBzdWNjZWVkcykgKi9cbiAgICAgIHRhcCgoKSA9PiB7IHRoaXMuI25vdGlmeShrZXksIHVuZGVmaW5lZCk7IH0pLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIGl0ZW1zIGluIHN0b3JhZ2UuXG4gICAqIFxuICAgKiBOb3RlIHRoYXQ6XG4gICAqICogeW91ICpkbyogbmVlZCB0byBzdWJzY3JpYmUsIGV2ZW4gaWYgeW91IGRvIG5vdCBoYXZlIHNvbWV0aGluZyBzcGVjaWZpYyB0byBkbyBhZnRlciBjbGVhcmluZywgb3RoZXJ3aXNlIG5vdGhpbmcgaGFwcGVucyAoYmVjYXVzZSBpdCBpcyBob3cgUnhKUyBPYnNlcnZhYmxlcyB3b3JrKSxcbiAgICogKiBidXQgeW91IGRvICpub3QqIG5lZWQgdG8gdW5zdWJzY3JpYmUgKGl0IGlzIGEgc2VsZi1jb21wbGV0aW5nIE9ic2VydmFibGUpLlxuICAgKiBcbiAgICogQHJldHVybnMgQSBSeEpTIE9ic2VydmFibGUgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmNsZWFyKCkuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICByZXR1cm4gdGhpcy4jZGF0YWJhc2UuY2xlYXIoKS5waXBlKFxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICB0aGlzLiNjYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLiNkYXRhYmFzZS5jbGVhcigpKSxcbiAgICAgIC8qIE5vdGlmeSB3YXRjaGVycyAobXVzdCBiZSBsYXN0IGJlY2F1c2UgaXQgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBvcGVyYXRpb24gc3VjY2VlZHMpICovXG4gICAgICB0YXAoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLiNub3RpZmllcnMua2V5cygpKSB7XG4gICAgICAgICAgdGhpcy4jbm90aWZ5KGtleSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwga2V5cyBzdG9yZWQgaW4gc3RvcmFnZS5cbiAgICogXG4gICAqIE5vdGUgKip0aGlzIGlzIGFuICppdGVyYXRpbmcqIE9ic2VydmFibGUqKjpcbiAgICogKiBpZiB0aGVyZSBpcyBubyBrZXksIHRoZSBgbmV4dGAgY2FsbGJhY2sgd2lsbCBub3QgYmUgaW52b2tlZCxcbiAgICogKiBpZiB5b3UgbmVlZCB0byB3YWl0IHRoZSB3aG9sZSBvcGVyYXRpb24gdG8gZW5kLCBiZSBzdXJlIHRvIGFjdCBpbiB0aGUgYGNvbXBsZXRlYCBjYWxsYmFjayxcbiAgICogYXMgdGhpcyBPYnNlcnZhYmxlIGNhbiBlbWl0IHNldmVyYWwgdmFsdWVzIGFuZCBzbyB3aWxsIGludm9rZSB0aGUgYG5leHRgIGNhbGxiYWNrIHNldmVyYWwgdGltZXMsXG4gICAqICogeW91IGRvICpub3QqIG5lZWQgdG8gdW5zdWJzY3JpYmUgKGl0IGlzIGEgc2VsZi1jb21wbGV0aW5nIE9ic2VydmFibGUpLlxuICAgKiBcbiAgICogQHJldHVybnMgQSBsaXN0IG9mIHRoZSBrZXlzIHdyYXBwZWQgaW4gYSBSeEpTIE9ic2VydmFibGVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmtleXMoKS5zdWJzY3JpYmUoe1xuICAgKiAgIG5leHQ6IChrZXkpID0+IHsgY29uc29sZS5sb2coa2V5KTsgfSxcbiAgICogICBjb21wbGV0ZTogKCkgPT4geyBjb25zb2xlLmxvZygnRG9uZScpOyB9LFxuICAgKiB9KTtcbiAgICovXG4gIGtleXMoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblxuICAgIHJldHVybiB0aGlzLiNkYXRhYmFzZS5rZXlzKClcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy4jY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy4jZGF0YWJhc2Uua2V5cygpKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxscyBpZiBhIGtleSBleGlzdHMgaW4gc3RvcmFnZS5cbiAgICogXG4gICAqIE5vdGUgeW91IGRvICpub3QqIG5lZWQgdG8gdW5zdWJzY3JpYmUgKGl0IGlzIGEgc2VsZi1jb21wbGV0aW5nIE9ic2VydmFibGUpLlxuICAgKiBcbiAgICogQHJldHVybnMgQSBSeEpTIE9ic2VydmFibGUgdGVsbGluZyBpZiB0aGUga2V5IGV4aXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuaGFzKCdrZXknKS5zdWJzY3JpYmUoKGhhc0tleSkgPT4ge1xuICAgKiAgIGlmIChoYXNLZXkpIHt9XG4gICAqIH0pO1xuICAgKi9cbiAgaGFzKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICByZXR1cm4gdGhpcy4jZGF0YWJhc2UuaGFzKGtleSlcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy4jY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy4jZGF0YWJhc2UuaGFzKGtleSkpKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFdhdGNoIGFuIGl0ZW0gdmFsdWUgaW4gc3RvcmFnZS5cbiAgICogXG4gICAqIE5vdGUgdGhhdDpcbiAgICogKiBpdCBpcyBhbiBpbmZpbml0ZSBPYnNlcnZhYmxlLCBkbyBub3QgZm9yZ2V0IHRvIHVuc3Vic2NyaWJlLFxuICAgKiAqIG9ubHkgY2hhbmdlcyBkb25lIHZpYSB0aGlzIGxpYnJhcnkgd2lsbCBiZSB3YXRjaGVkLCBleHRlcm5hbCBjaGFuZ2VzIGluIHN0b3JhZ2UgY2Fubm90IGJlIGRldGVjdGVkLlxuICAgKiBcbiAgICogVGhlIHNpZ25hdHVyZSBoYXMgbWFueSBvdmVybG9hZHMgZHVlIHRvIHZhbGlkYXRpb24sICoqcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLioqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9WQUxJREFUSU9OLm1kXG4gICAqIFxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5IHRvIHdhdGNoXG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIGluaXRpYWwgdmFsdWVcbiAgICogQHJldHVybnMgQW4gaW5maW5pdGUgT2JzZXJ2YWJsZSBnaXZpbmcgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICogXG4gICAqIEBleGFtcGxlXG4gICAqIENvbXBvbmVudCgpXG4gICAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICogXG4gICAqICAgcHJpdmF0ZSBzdG9yYWdlU3Vic2NyaXB0aW9uPzogU3Vic2NyaXB0aW9uO1xuICAgKiBcbiAgICogICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICogICAgIHRoaXMuc3RvcmFnZVN1YnNjcmlwdGlvbiA9IHRoaXMuc3RvcmFnZU1hcC53YXRjaCgna2V5JywgeyB0eXBlOiAnc3RyaW5nJyB9KS5zdWJzY3JpYmUoKHJlc3VsdCkgPT4ge1xuICAgKiAgICAgICByZXN1bHQ7IC8vIHN0cmluZyBvciB1bmRlZmluZWRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICogXG4gICAqICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAqICAgICB0aGlzLnN0b3JhZ2VTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAqICAgfVxuICAgKiBcbiAgICogfVxuICAgKi9cbiAgd2F0Y2goa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd24+O1xuICB3YXRjaDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hU3RyaW5nKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCBleHRlbmRzIG51bWJlciA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQgZXh0ZW5kcyByZWFkb25seSBzdHJpbmdbXSA9IHN0cmluZ1tdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hU3RyaW5nPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzIC0tIEJldHRlciBmb3IgZG9jdW1lbnRhdGlvblxuICB3YXRjaDxUIGV4dGVuZHMgcmVhZG9ubHkgbnVtYmVyW10gPSBudW1iZXJbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzIC0tIEJldHRlciBmb3IgZG9jdW1lbnRhdGlvblxuICB3YXRjaDxUIGV4dGVuZHMgcmVhZG9ubHkgYm9vbGVhbltdID0gYm9vbGVhbltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hQm9vbGVhbj4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICB3YXRjaDxUPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCA9IHVua25vd24+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmtub3duPiB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm90aWZpZXIgKi9cbiAgICBpZiAoIXRoaXMuI25vdGlmaWVycy5oYXMoa2V5KSkge1xuICAgICAgdGhpcy4jbm90aWZpZXJzLnNldChrZXksIG5ldyBSZXBsYXlTdWJqZWN0KDEpKTtcbiAgICB9XG5cbiAgICAvKiBOb24tbnVsbCBhc3NlcnRpb24gaXMgcmVxdWlyZWQgYmVjYXVzZSBUeXBlU2NyaXB0IGRvZXNuJ3QgbmFycm93IGAuaGFzKClgIHlldCAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uIC0tIEVuc3VyZWQgYnkgdGhlIGxvZ2ljXG4gICAgY29uc3Qgbm90aWZpZXIgPSB0aGlzLiNub3RpZmllcnMuZ2V0KGtleSkhO1xuXG4gICAgLyogR2V0IHRoZSBjdXJyZW50IGl0ZW0gdmFsdWUgKi9cbiAgICAoc2NoZW1hID8gdGhpcy5nZXQ8VD4oa2V5LCBzY2hlbWEpIDogdGhpcy5nZXQoa2V5KSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChyZXN1bHQpID0+IHtcbiAgICAgICAgbm90aWZpZXIubmV4dChyZXN1bHQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgbm90aWZpZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qIE9ubHkgdGhlIHB1YmxpYyBBUEkgb2YgdGhlIE9ic2VydmFibGUgc2hvdWxkIGJlIHJldHVybmVkICovXG4gICAgcmV0dXJuIChzY2hlbWEgP1xuICAgICAgbm90aWZpZXIuYXNPYnNlcnZhYmxlKCkgYXMgT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPiA6XG4gICAgICBub3RpZmllci5hc09ic2VydmFibGUoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgd2hlbiBhIHZhbHVlIGNoYW5nZXNcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgbmV3IHZhbHVlXG4gICAqL1xuICAjbm90aWZ5KGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHZvaWQge1xuXG4gICAgY29uc3Qgbm90aWZpZXIgPSB0aGlzLiNub3RpZmllcnMuZ2V0KGtleSk7XG5cbiAgICBpZiAobm90aWZpZXIpIHtcbiAgICAgIG5vdGlmaWVyLm5leHQodmFsdWUpO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIFJ4SlMgb3BlcmF0b3IgdG8gY2F0Y2ggaWYgYGluZGV4ZWREQmAgaXMgYnJva2VuXG4gICAqIEBwYXJhbSBvcGVyYXRpb25DYWxsYmFjayBDYWxsYmFjayB3aXRoIHRoZSBvcGVyYXRpb24gdG8gcmVkb1xuICAgKi9cbiAgI2NhdGNoSURCQnJva2VuPFQ+KG9wZXJhdGlvbkNhbGxiYWNrOiAoKSA9PiBPYnNlcnZhYmxlPFQ+KTogT3BlcmF0b3JGdW5jdGlvbjxULCBUPiB7XG5cbiAgICByZXR1cm4gY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcblxuICAgICAgLyogQ2hlY2sgaWYgYGluZGV4ZWREQmAgaXMgYnJva2VuIGJhc2VkIG9uIGVycm9yIG1lc3NhZ2UgKHRoZSBzcGVjaWZpYyBlcnJvciBjbGFzcyBzZWVtcyB0byBiZSBsb3N0IGluIHRoZSBwcm9jZXNzKSAqL1xuICAgICAgaWYgKChlcnJvciAhPT0gdW5kZWZpbmVkKSAmJiAoZXJyb3IgIT09IG51bGwpXG4gICAgICAgICYmICh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIpICYmIChcIm1lc3NhZ2VcIiBpbiBlcnJvcilcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAtLSBSZXF1aXJlZCBiZWNhdXNlIFR5cGVTY3JpcHQgbmFycm93aW5nIGlzIG5vdCB3b3JraW5nIGhlcmVcbiAgICAgICAgJiYgKGVycm9yLm1lc3NhZ2UgPT09IElEQl9CUk9LRU5fRVJST1IpKSB7XG5cbiAgICAgICAgLyogV2hlbiBzdG9yYWdlIGlzIGZ1bGx5IGRpc2FibGVkIGluIGJyb3dzZXIgKHZpYSB0aGUgXCJCbG9jayBhbGwgY29va2llc1wiIG9wdGlvbiksXG4gICAgICAgICAqIGp1c3QgdHJ5aW5nIHRvIGNoZWNrIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIGNhdXNlcyBhIHNlY3VyaXR5IGV4Y2VwdGlvbi5cbiAgICAgICAgICogUHJldmVudHMgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvMTE4XG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgaWYgKFwiZ2V0SXRlbVwiIGluIGxvY2FsU3RvcmFnZSkge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBgbG9jYWxTdG9yYWdlYCBpZiBhdmFpbGFibGUgKi9cbiAgICAgICAgICAgIHRoaXMuI2RhdGFiYXNlID0gbmV3IExvY2FsU3RvcmFnZURhdGFiYXNlKCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBtZW1vcnkgc3RvcmFnZSBvdGhlcndpc2UgKi9cbiAgICAgICAgICAgIHRoaXMuI2RhdGFiYXNlID0gbmV3IE1lbW9yeURhdGFiYXNlKCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCB7XG5cbiAgICAgICAgICAvKiBGYWxsYmFjayB0byBtZW1vcnkgc3RvcmFnZSBvdGhlcndpc2UgKi9cbiAgICAgICAgICB0aGlzLiNkYXRhYmFzZSA9IG5ldyBNZW1vcnlEYXRhYmFzZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBSZWRvIHRoZSBvcGVyYXRpb24gKi9cbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbkNhbGxiYWNrKCk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLyogT3RoZXJ3aXNlLCByZXRocm93IHRoZSBlcnJvciAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoKCkgPT4gZXJyb3IpO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFRISVMgTUVUSE9EIElTIEZPUiBJTlRFUk5BTCBQVVJQT1NFIE9OTFkgQU5EIE1VU1QgTk9UIEJFIFVTRUQsXG4gICAqIElUIENBTiBCRSBSRU1PVkVEIEFUIEFOWSBUSU1FIEFORCBNRVNTSU5HIFdJVEggSVQgQ0FOIENBVVNFIElTU1VFU1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAaWdub3JlXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXRzLWV4cGVjdC1lcnJvciAtLSBTaWxlbmNlIHRoZSBub3QgdXNlZCBlcnJvciwgaXQgaXMgdXNlZCBpbiB0ZXN0c1xuICAvLyBAdHMtaWdub3JlXG4gIHByaXZhdGUgybVpbnRlcm5hbEdldERhdGFiYXNlKCk6IExvY2FsRGF0YWJhc2Uge1xuXG4gICAgcmV0dXJuIHRoaXMuI2RhdGFiYXNlO1xuXG4gIH1cblxufVxuIl19