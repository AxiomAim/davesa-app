import { Observable } from "rxjs";
import { LocalDatabase } from "../databases/local-database";
import type { JSONSchema, JSONSchemaArrayOf, JSONSchemaBoolean, JSONSchemaInteger, JSONSchemaNumber, JSONSchemaString } from "../validation/json-schema";
import * as i0 from "@angular/core";
export declare class StorageMap {
    #private;
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param database Storage to use
     */
    constructor(database: LocalDatabase);
    /**
     * **Number of items** in storage, wrapped in an Observable.
     *
     * Note you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @example
     * this.storageMap.size.subscribe((size) => {
     *   console.log(size);
     * });
     */
    get size(): Observable<number>;
    /**
     * Tells you which storage engine is used.
     *
     * *Only useful for interoperability.*
     *
     * Note that due to some browsers issues in some special contexts
     * (like Safari cross-origin iframes),
     * **this information may be wrong at initialization,**
     * as the storage could fallback from `indexedDB` to `localStorage`
     * only after a first read or write operation.
     * @returns Storage engine used
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {}
     */
    get backingEngine(): "indexedDB" | "localStorage" | "memory" | "unknown";
    /**
     * Information about `indexedDB` database.
     *
     * *Only useful for interoperability.*
     *
     * @returns `indexedDB` database name, store name and database version.
     * **Values will be empty if the storage is not `indexedDB`, so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {
     *   const { database, store, version } = this.storageMap.backingStore;
     * }
     */
    get backingStore(): {
        database: string;
        store: string;
        version: number;
    };
    /**
     * Information about `localStorage` fallback storage.
     *
     * *Only useful for interoperability.*
     *
     * @returns `localStorage` prefix.
     * **Values will be empty if the storage is not `localStorage`, so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'localStorage') {
     *   const { prefix } = this.storageMap.fallbackBackingStore;
     * }
     */
    get fallbackBackingStore(): {
        prefix: string;
    };
    /**
     * Get an item value in storage.
     *
     * Note that:
     * * not finding an item is not an error, it succeeds but returns `undefined`,
     * * you do *not* need to unsubscribe (it is a self-completing Observable),
     * * you will only get *one* value: the Observable is here for asynchrony but is *not* meant to emit again when the stored data is changed. If you need to watch the value, see the `watch` method.
     *
     * Do not forget it is client-side storage: **always check the data**, as it could have been forged.
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}
     *
     * @param key The item's key
     * @param schema Optional but recommended JSON schema to validate the data
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS Observable
     *
     * @example
     * this.storageMap.get('key', { type: 'string' }).subscribe((result) => {
     *   result; // string or undefined
     * });
     *
     * @example
     * interface User {
     *   firstName: string;
     *   lastName?: string;
     * }
     *
     * const schema = {
     *   type: 'object',
     *   properties: {
     *     firstName: { type: 'string' },
     *     lastName: { type: 'string' },
     *   },
     *   required: ['firstName'],
     * } satisfies JSONSchema;
     *
     * this.storageMap.get<User>('user', schema).subscribe((user) => {
     *   if (user) {
     *     user.firstName;
     *   }
     * });
     */
    get(key: string): Observable<unknown>;
    get<T extends string = string>(key: string, schema: JSONSchemaString): Observable<T | undefined>;
    get<T extends number = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<T | undefined>;
    get<T extends boolean = boolean>(key: string, schema: JSONSchemaBoolean): Observable<T | undefined>;
    get<T extends readonly string[] = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<T | undefined>;
    get<T extends readonly number[] = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<T | undefined>;
    get<T extends readonly boolean[] = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<T | undefined>;
    get<T>(key: string, schema: JSONSchema): Observable<T | undefined>;
    /**
     * Store an item in storage.
     *
     * Note that:
     * * you *do* need to subscribe, even if you do not have something specific to do after writing in storage, otherwise nothing happens (because it is how RxJS Observables work),
     * * but you do *not* need to unsubscribe (it is a self-completing Observable),
     * * setting `null` or `undefined` will remove the item to avoid some browsers issues,
     * * you should stick to serializable JSON data, meaning primitive types, arrays and literal objects. Date, Map, Set, Blob and other special structures can cause issues in some scenarios.
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/SERIALIZATION.md}
     *
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS Observable to wait the end of the operation
     *
     * @example
     * this.storageMap.set('key', 'value').subscribe(() => {});
     */
    set(key: string, data: unknown, schema?: JSONSchema): Observable<undefined>;
    /**
     * Delete an item in storage.
     *
     * Note that:
     * * you *do* need to subscribe, even if you do not have something specific to do after deleting, otherwise nothing happens (because it is how RxJS Observables work),
     * * but you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @param key The item's key
     * @returns A RxJS Observable to wait the end of the operation
     *
     * @example
     * this.storageMap.delete('key').subscribe(() => {});
     */
    delete(key: string): Observable<undefined>;
    /**
     * Delete all items in storage.
     *
     * Note that:
     * * you *do* need to subscribe, even if you do not have something specific to do after clearing, otherwise nothing happens (because it is how RxJS Observables work),
     * * but you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @returns A RxJS Observable to wait the end of the operation
     *
     * @example
     * this.storageMap.clear().subscribe(() => {});
     */
    clear(): Observable<undefined>;
    /**
     * Get all keys stored in storage.
     *
     * Note **this is an *iterating* Observable**:
     * * if there is no key, the `next` callback will not be invoked,
     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,
     * as this Observable can emit several values and so will invoke the `next` callback several times,
     * * you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @returns A list of the keys wrapped in a RxJS Observable
     *
     * @example
     * this.storageMap.keys().subscribe({
     *   next: (key) => { console.log(key); },
     *   complete: () => { console.log('Done'); },
     * });
     */
    keys(): Observable<string>;
    /**
     * Tells if a key exists in storage.
     *
     * Note you do *not* need to unsubscribe (it is a self-completing Observable).
     *
     * @returns A RxJS Observable telling if the key exists
     *
     * @example
     * this.storageMap.has('key').subscribe((hasKey) => {
     *   if (hasKey) {}
     * });
     */
    has(key: string): Observable<boolean>;
    /**
     * Watch an item value in storage.
     *
     * Note that:
     * * it is an infinite Observable, do not forget to unsubscribe,
     * * only changes done via this library will be watched, external changes in storage cannot be detected.
     *
     * The signature has many overloads due to validation, **please refer to the documentation.**
     * @see https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md
     *
     * @param key The item's key to watch
     * @param schema Optional JSON schema to validate the initial value
     * @returns An infinite Observable giving the current value
     *
     * @example
     * Component()
     * export class MyComponent implements OnInit, OnDestroy {
     *
     *   private storageSubscription?: Subscription;
     *
     *   ngOnInit(): void {
     *     this.storageSubscription = this.storageMap.watch('key', { type: 'string' }).subscribe((result) => {
     *       result; // string or undefined
     *     });
     *   }
     *
     *   ngOnDestroy(): void {
     *     this.storageSubscription?.unsubscribe();
     *   }
     *
     * }
     */
    watch(key: string): Observable<unknown>;
    watch<T extends string = string>(key: string, schema: JSONSchemaString): Observable<T | undefined>;
    watch<T extends number = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<T | undefined>;
    watch<T extends boolean = boolean>(key: string, schema: JSONSchemaBoolean): Observable<T | undefined>;
    watch<T extends readonly string[] = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<T | undefined>;
    watch<T extends readonly number[] = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<T | undefined>;
    watch<T extends readonly boolean[] = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<T | undefined>;
    watch<T>(key: string, schema: JSONSchema): Observable<T | undefined>;
    /**
     * THIS METHOD IS FOR INTERNAL PURPOSE ONLY AND MUST NOT BE USED,
     * IT CAN BE REMOVED AT ANY TIME AND MESSING WITH IT CAN CAUSE ISSUES
     * @private
     * @ignore
     */
    private ɵinternalGetDatabase;
    static ɵfac: i0.ɵɵFactoryDeclaration<StorageMap, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<StorageMap>;
}
